#+STARTUP: content

* emacs config

** Learning
*** Examples of emacs config

 - https://github.com/rememberYou/.emacs.d/blob/master/config.org
 - https://wolfecub.github.io/dotfiles/
 - https://github.com/gilbertw1/emacs-literate-starter/blob/master/emacs.org
 - https://github.com/emacs-tw/awesome-emacs
 - https://github.com/munen/emacs.d/ (from presentation https://www.youtube.com/watch?v=gfZDwYeBlO4)
 - https://matthewbauer.us/bauer/

*** Emacs editor movement to remember

**** Movement
    - C-a, C-e: Begining/end of the line
    - M-a, M-e: Begining/end of a sentence
    - M-d     : Kill word (forward until next change of word
    - M-- M-d : Kill word (but backwards because the M-- means modifier -1)
    - 

**** Interesting Keybinding
    - M-;: Comment
    - F3 : Start Macro
    - F4 : Stops Macro
    - C-x z: Repeat last command (press z again without C-x to repeat)
    - C-M-i: Auto complete
    - C-SPC: Starts a region and adds a mark
    - C-x C-x: swaps cursor and mark
    - C-x C-e: Execute sexp after the cursor
    - . on dired mode: Shows dired hydra help menu

**** Help - Describe 
    - C-h f: Describe function
    - C-h m: Describe mode
    - C-h k: Describe key
    - C-h v: Describe variablle

**** Concepts

***** DWIM (Do What I Mean)

https://www.emacswiki.org/emacs/DoWhatIMean#DWIM

For example when setted the `dired-dwim-target` variable, if you have two windows with dired
and copy/move a file, will do directly with the other window. Because assumes that's what you want

#+BEGIN_SRC emacs-lisp

(setq dired-dwim-target t)


#+END_SRC

***** Narrow 

C-x n n: Narrow to region, means that temporary you only see the region on the current buffer
C-x n w: Widen the region

***** Register

https://www.gnu.org/software/emacs/manual/html_node/emacs/Bookmarks.html

Bookmarks are cursor positions stored, like in register but are persisted
between emacs sessions

By default bookmarks are at C-x r, but for me it better to have them at C-c b

C-c b b: set bookmark

C-c b j: Go to a bookmark

C-c b l: Show list of bookmarks

#+BEGIN_SRC emacs-lisp :tangle yes

  (global-set-key (kbd "C-c b j") 'bookmark-jump)

  (global-set-key (kbd "C-c b b") 'bookmark-set)

  (global-set-key (kbd "C-c b l") 'bookmark-bmenu-list)

#+END_SRC

****** Windows

You can save your window-configurations:

window-configuration-to-register C-x r w

and restore it later:

jump-to-register C-x r j

***** Org babel

1. <s <TAB> expands a code region :)

2. Inside a code region you can press C-c ' and the code will open in another windw
   with proper identation color etc...


** config
*** Set GC

#+BEGIN_SRC emacs-lisp :tangle yes

(setq gc-cons-threshold 20000000)

#+END_SRC!

*** use-package
Configure use-package to install next package

#+BEGIN_SRC emacs-lisp :tangle yes
(require 'package)

(add-to-list 'package-archives '("melpa" . "https://melpa.org/packages/"))
(add-to-list 'package-archives '("org" . "http://orgmode.org/elpa/"))

(package-initialize)

;; install use-package if not installed
(unless (require 'use-package nil t)
    (package-refresh-contents)
    (package-install 'use-package)
    (require 'use-package))

;; install package if not already in
(setq use-package-always-ensure t)
#+END_SRC

*** Not Temp files plz!

#+BEGIN_SRC emacs-lisp :tangle yes

(setq make-backup-files nil)

(setq backup-directory-alist
      `((".*" . ,temporary-file-directory)))

(setq auto-save-file-name-transforms
      `((".*" ,temporary-file-directory t)))

#+END_SRC

*** Dimish

Diminish is used to no clutter the bottom bar with all the, one cool thing is that while
using use-package, you can add a :diminish to hide it directly

https://github.com/myrjola/diminish.el
#+BEGIN_SRC emacs-lisp :tangle yes

(use-package diminish)

#+END_SRC

*** Basic editing and UI
Configure basic UI, remove menu, scrollbar etc...

#+BEGIN_SRC emacs-lisp :tangle yes
(if (display-graphic-p)
    (progn
      (menu-bar-mode -1)
      (toggle-scroll-bar -1)
      (tool-bar-mode -1)))

(defalias 'yes-or-no-p 'y-or-n-p)

#+END_SRC


Desktop save mode saves the session of the emacs between executions
More info: https://www.gnu.org/software/emacs/manual/html_node/emacs/Saving-Emacs-Sessions.html#Saving-Emacs-Sessions

#+BEGIN_SRC emacs-lisp :tangle yes

(desktop-save-mode 1)


(setq desktop-buffers-not-to-save
    (concat "\\("
	    "^nn\\.a[0-9]+\\|\\.log\\|(ftp)\\|^tags\\|^TAGS"
	    "\\|\\.emacs.*\\|\\.diary\\|\\.newsrc-dribble\\|\\.bbdb"
    "\\)$"))
(add-to-list 'desktop-modes-not-to-save 'dired-mode)
(add-to-list 'desktop-modes-not-to-save 'Info-mode)
(add-to-list 'desktop-modes-not-to-save 'info-lookup-mode)
(add-to-list 'desktop-modes-not-to-save 'fundamental-mode)

#+END_SRC

Also no use of tabs....

#+BEGIN_SRC emacs-lisp :tangle yes

(setq-default indent-tabs-mode nil)

#+END_SRC
*** IDO 

IDO (Interactive DO) https://www.gnu.org/software/emacs/manual/html_mono/ido.html) 

is already built in into the Emacs system... it helps you when there are multiple options 
on the mini-buffer of emacs such as find-file or switch-buffer


#+BEGIN_SRC emacs-lisp :tangle yes
;; Since is already in we don't need to use-package it

(ido-mode 1)
(ido-everywhere 1)
#+END_SRC

*** Projectile

Projectile (https://github.com/bbatsov/projectile) 

Allow you to do find-file and search inside your project only

#+BEGIN_SRC emacs-lisp :tangle yes

(use-package projectile
:bind-keymap
("C-c p" . projectile-command-map))

#+END_SRC

*** OSX

#+BEGIN_SRC emacs-lisp :tangle yes
;; key bindings
(when (eq system-type 'darwin) ;; mac specific settings
(setq mac-option-modifier 'alt)
(setq mac-command-modifier 'meta)
(global-set-key [kp-delete] 'delete-char) ;; sets fn-delete to be right-delete
(setq mac-right-option-modifier 'none))


#+END_SRC

*** Load theme

#+BEGIN_SRC emacs-lisp :tangle yes

(use-package leuven-theme
:init (load-theme 'leuven t))

#+END_SRC

*** Clipboard

Make copy and paste from the clipboard work on emacs
from: http://ergoemacs.org/emacs/emacs_x11_sync_clipboard.html

#+BEGIN_SRC emacs-lisp :tangle yes

;; after copy Ctrl+c in Linux X11, you can paste by `yank' in emacs
(setq x-select-enable-clipboard t)

;; after mouse selection in X11, you can paste by `yank' in emacs
(setq x-select-enable-primary t)

#+END_SRC

*** Which Key

Which key is a minor mode that allow you to see which keystrokes are available after a prefix

For example: when you press C-c, after a second it would show up what are the next keybinding you can use

#+BEGIN_SRC emacs-lisp :tangle yes

(use-package which-key
  :diminish
  :config
  (setq which-key-idle-delay 0.2)
  (which-key-mode))


#+END_SRC

*** Undo tree

Undo tree allow you yo see how to undo/redo

#+BEGIN_SRC emacs-lisp :tangle yes

(use-package undo-tree
  :diminish
  :bind (
  ("C-z" . undo)
  ("C-c _" . undo-tree-visualize)
  ("C-S-z" . undo-tree-redo))
  :config
  (global-undo-tree-mode 1))

#+END_SRC

*** GIT!
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package magit
  :bind (("C-c g" . magit-status)))
#+END_SRC

*** Expand Region

#+BEGIN_SRC emacs-lisp :tangle yes

(use-package expand-region
  :ensure
  :bind
  (("C-+" . er/expand-region)
  ("C-M-+" . er/contract-region)))


#+END_SRC

*** Multiple cursors
https://github.com/magnars/multiple-cursors.el

Multiple cursors allow you to change multiple parts of the file that share some text

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package multiple-cursors
  :bind
  (("<C-S-down>" . mc/mark-next-like-this)
  ("<C-S-up>" . mc/mark-previous-like-this)
  ("C-S-c c" . mc/mark-all-like-this-dwim)
  ("C-S-c r" . mc/mark-previous-like-this)
  ("C->" . mc/mark-next-like-this)
  ("C-<" . mc/mark-previous-like-this)
  ("C-S-c C-S-c" . mc/edit-lines)))

#+END_SRC

Since yet not fluent.... I have a hydra menu

C-c m c (Menu for cursors) allow you to open this menu

- n/p: to add a new cursor on next line
- N/P: skip next line to add a cursor
- a: (mark-all) will use the region as a search and add a cursor for each match
- r: does the same but with an regex on the current region
- C-Shift-c C-Shift-c: Add a cursor at the beginning of each line in the

*** Winner mode

Winner mode allow you to undo window open/close configuration etc...

#+BEGIN_SRC emacs-lisp :tangle yes

(use-package winner
  :diminish
  :init
  (winner-mode 1)
  :bind
  (("C-c w _" . winner-undo)
   ("C-c w -" . winner-redo)))

#+END_SRC

*** Eshell Configuration

    Copied from https://github.com/csand/emacs.d/blob/c6a2f45a62ddf498ac5f5d784d5f90ba155c35ea/init/init-eshell.el

    Visual commands is a way to say to eshell, for specific commands use ansi-term, and that's is necessary
    because if not, the tty is not attached and you can not use interactive command
#+BEGIN_SRC emacs-lisp :tangle yes


(use-package eshell
  :init
  (progn
    (setq
     eshell-hist-ignoredups t
     eshell-save-history-on-exit t
     eshell-prefer-lisp-functions t
     eshell-destroy-buffer-when-process-dies t))
  :config
  (add-to-list 'eshell-modules-list 'eshell-tramp))

;; Visual Commands
(add-hook 'eshell-mode-hook
              (lambda ()
                (add-to-list 'eshell-visual-commands "ssh")
                (add-to-list 'eshell-visual-commands "tail")
                (add-to-list 'eshell-visual-commands "docker")
                (add-to-list 'eshell-visual-commands "top")))

;; Aliases
(add-hook 'eshell-mode-hook
          (lambda ()
            (eshell/alias "e" "find-file $1")
            (eshell/alias "ff" "find-file $1")
            (eshell/alias "emacs" "find-file $1")
            (eshell/alias "ee" "find-file-other-window $1")))

#+END_SRC


*** Hydra menus


#+BEGIN_SRC emacs-lisp :tangle yes

  (use-package hydra
    :defer 2
    :config
    (define-key dired-mode-map "." 'hydra-dired/body)
    :bind (("C-c m w" . hydra-windows/body)
           ("C-c m c" . multiple-cursors-hydra/body)
           ("C-c m o" . hydra-org)))

#+END_SRC

**** Windows
  #+BEGIN_SRC emacs-lisp :tangle yes

  (defhydra hydra-windows (:color pink)
    "
    ^
    ^Windows^           ^Window^            ^Zoom^
    ^───────^───────────^──────^────────────^────^──────
    _q_ quit            _b_ balance         _-_ out
    _u_ undo            _i_ heighten        _+_ in
    _r_ redo            _j_ narrow          _=_ reset
    ^^                  _k_ lower           ^^
    ^^                  _l_ widen           ^^
    ^^                  ^^                  ^^
    "
    ("q" nil)
    ("b" balance-windows)
    ("i" enlarge-window)
    ("j" shrink-window-horizontally)
    ("k" shrink-window)
    ("l" enlarge-window-horizontally)
    ("-" text-scale-decrease)
    ("+" text-scale-increase)
    ("u" winner-undo)
    ("r" winner-redo)
    ("=" (text-scale-increase 0)))


  #+END_SRC

**** Org
#+BEGIN_SRC emacs-lisp :tangle yes

(defhydra hydra-org (:color red :columns 3)
  "Org Mode Movements"
  ("n" outline-next-visible-heading "next heading")
  ("p" outline-previous-visible-heading "prev heading")
  ("N" org-forward-heading-same-level "next heading at same level")
  ("P" org-backward-heading-same-level "prev heading at same level")
  ("u" outline-up-heading "up heading")
  ("g" org-goto "goto" :exit t))

#+END_SRC

**** Dired

#+BEGIN_SRC emacs-lisp :tangle yes

(defhydra hydra-dired (:hint nil :color pink)
  "
_+_ mkdir          _v_iew           _m_ark             _(_ details        _i_nsert-subdir    wdired
_C_opy             _O_ view other   _U_nmark all       _)_ omit-mode      _$_ hide-subdir    C-x C-q : edit
_D_elete           _o_pen other     _u_nmark           _l_ redisplay      _w_ kill-subdir    C-c C-c : commit
_R_ename           _M_ chmod        _t_oggle           _g_ revert buf     _e_ ediff          C-c ESC : abort
_Y_ rel symlink    _G_ chgrp        _E_xtension mark   _s_ort             _=_ pdiff
_S_ymlink          ^ ^              _F_ind marked      _._ toggle hydra   \\ flyspell
_r_sync            ^ ^              ^ ^                ^ ^                _?_ summary
_z_ compress-file  _A_ find regexp
_Z_ compress       _Q_ repl regexp

T - tag prefix
"
  ("\\" dired-do-ispell)
  ("(" dired-hide-details-mode)
  (")" dired-omit-mode)
  ("+" dired-create-directory)
  ("=" diredp-ediff)         ;; smart diff
  ("?" dired-summary)
  ("$" diredp-hide-subdir-nomove)
  ("A" dired-do-find-regexp)
  ("C" dired-do-copy)        ;; Copy all marked files
  ("D" dired-do-delete)
  ("E" dired-mark-extension)
  ("e" dired-ediff-files)
  ("F" dired-do-find-marked-files)
  ("G" dired-do-chgrp)
  ("g" revert-buffer)        ;; read all directories again (refresh)
  ("i" dired-maybe-insert-subdir)
  ("l" dired-do-redisplay)   ;; relist the marked or singel directory
  ("M" dired-do-chmod)
  ("m" dired-mark)
  ("O" dired-display-file)
  ("o" dired-find-file-other-window)
  ("Q" dired-do-find-regexp-and-replace)
  ("R" dired-do-rename)
  ("r" dired-do-rsynch)
  ("S" dired-do-symlink)
  ("s" dired-sort-toggle-or-edit)
  ("t" dired-toggle-marks)
  ("U" dired-unmark-all-marks)
  ("u" dired-unmark)
  ("v" dired-view-file)      ;; q to exit, s to search, = gets line #
  ("w" dired-kill-subdir)
  ("Y" dired-do-relsymlink)
  ("z" diredp-compress-this-file)
  ("Z" dired-do-compress)
  ("q" nil)
  ("." nil :color blue))


#+END_SRC

**** Multiple Cursor

#+BEGIN_SRC emacs-lisp

(defhydra multiple-cursors-hydra (:hint nil)
  "
     ^Up^            ^Down^        ^Other^
----------------------------------------------
[_p_]   Next    [_n_]   Next    [_l_] Edit lines
[_P_]   Skip    [_N_]   Skip    [_a_] Mark all
[_M-p_] Unmark  [_M-n_] Unmark  [_r_] Mark by regexp
^ ^             ^ ^             [_q_] Quit
"
  ("l" mc/edit-lines :exit t)
  ("a" mc/mark-all-like-this :exit t)
  ("n" mc/mark-next-like-this)
  ("N" mc/skip-to-next-like-this)
  ("M-n" mc/unmark-next-like-this)
  ("p" mc/mark-previous-like-this)
  ("P" mc/skip-to-previous-like-this)
  ("M-p" mc/unmark-previous-like-this)
  ("r" mc/mark-all-in-region-regexp :exit t)
  ("q" nil))

#+END_SRC

** EXPERIMENTAL!!!!
*** Javascrip

https://www.reddit.com/r/emacs/comments/6u1js5/vscode_really_outshines_emacs_when_it_comes/

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package rjsx-mode
    :config
    ((lambda ()
       (add-to-list 'auto-mode-alist '("\\.jsx?\\'" . rjsx-mode))
       (add-hook 'js2-mode-hook (lambda () (setq js2-basic-offset 2))))))

  (use-package js2-refactor
    :config
    ((lambda ()
       (add-hook 'js2-mode-hook #'js2-refactor-mode)
       (js2r-add-keybindings-with-prefix "C-c C-r")
       (define-key js2-mode-map (kbd "C-k") #'js2r-kill))))

  (use-package xref-js2
    :config
    ((lambda ()
       ;; js-mode (which js2 is based on) binds "M-." which conflicts with xref, so
       ;; unbind it.
       (define-key js-mode-map (kbd "M-.") nil)
       (add-hook 'js2-mode-hook
                 (lambda ()
                   (add-hook 'xref-backend-functions
                             #'xref-js2-xref-backend
                             nil t))))))

  ;; (use-package company-tern
  ;;   :config
  ;;   ((lambda ()
  ;;      (add-to-list 'company-backends 'company-tern)
  ;;      (add-hook 'js2-mode-hook
  ;;                (lambda ()
  ;;                  (tern-mode)
  ;;                  (company-mode)
  ;;                  ;; Disable completion keybindings, as we use xref-js2 instead
  ;;                  (define-key tern-mode-keymap (kbd "M-.") nil)



#+END_SRC


For add eslint using the one in the project...
copied from: https://github.com/eastwood/config/blob/master/emacs.d/emacs.org


#+BEGIN_SRC emacs-lisp :tangle
  (use-package flycheck
    :init
    (autoload 'pkg-info-version-info "pkg-info")
    (setq-default flycheck-disabled-checker 'javascript-jshint)
    (setq-default flycheck-disabled-checker 'json-jsonlist)
    (setq-default flycheck-disabled-checker 'javascript-eslint)
    (flycheck-add-mode 'javascript-eslint 'js2-mode)

    (defun my/use-eslint-from-node-modules ()
      (let* ((root (locate-dominating-file
      (or (buffer-file-name) default-directory)
        "node_modules"))
        (eslint (and root
        (expand-file-name "node_modules/eslint/bin/eslint.js"
          root))))
        (when (and eslint (file-executable-p eslint))
      (setq-local flycheck-javascript-eslint-executable eslint))))
    (add-hook 'flycheck-mode-hook #'my/use-eslint-from-node-modules)
    (global-flycheck-mode))

#+END_SRC

** TODO
*** Evil ????? 

I want evil just for movement but not for anything else...

#+BEGIN_SRC emacs-lisp :tangle yes

(use-package evil)

#+END_SRC

For the moment I install the package but not used by default but
you need to start it by M-x evil-mode

Also found this for better having some keybindings from emacs like
C-e and C-f etc...
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package evil
  :config
  (define-key evil-normal-state-map "\C-e" 'evil-end-of-line)
  (define-key evil-insert-state-map "\C-e" 'end-of-line)
  (define-key evil-visual-state-map "\C-e" 'evil-end-of-line)
  (define-key evil-motion-state-map "\C-e" 'evil-end-of-line)
  (define-key evil-normal-state-map "\C-f" 'evil-forward-char)
  (define-key evil-insert-state-map "\C-f" 'evil-forward-char)
  (define-key evil-insert-state-map "\C-f" 'evil-forward-char)
  (define-key evil-normal-state-map "\C-b" 'evil-backward-char)
  (define-key evil-insert-state-map "\C-b" 'evil-backward-char)
  (define-key evil-visual-state-map "\C-b" 'evil-backward-char)
  (define-key evil-normal-state-map "\C-d" 'evil-delete-char)
  (define-key evil-insert-state-map "\C-d" 'evil-delete-char)
  (define-key evil-visual-state-map "\C-d" 'evil-delete-char)
  (define-key evil-normal-state-map "\C-n" 'evil-next-line)
  (define-key evil-insert-state-map "\C-n" 'evil-next-line)
  (define-key evil-visual-state-map "\C-n" 'evil-next-line)
  (define-key evil-normal-state-map "\C-p" 'evil-previous-line)
  (define-key evil-insert-state-map "\C-p" 'evil-previous-line)
  (define-key evil-visual-state-map "\C-p" 'evil-previous-line)
  (define-key evil-normal-state-map "\C-w" 'evil-delete)
  (define-key evil-insert-state-map "\C-w" 'evil-delete)
  (define-key evil-visual-state-map "\C-w" 'evil-delete)
  (define-key evil-normal-state-map "\C-y" 'yank)
  (define-key evil-insert-state-map "\C-y" 'yank)
  (define-key evil-visual-state-map "\C-y" 'yank)
  (define-key evil-normal-state-map "\C-k" 'kill-line)
  (define-key evil-insert-state-map "\C-k" 'kill-line)
  (define-key evil-visual-state-map "\C-k" 'kill-line))

#+END_SRC

*** Eyebrowser / perspective

I would love yo have a way to organize my code programming like a shell at the bottom and a 
tree (dired) and a couple of buffers and be able to switch between them fast and easy just 
like in sublime or something :)

*** Ivy / Swipper / Counsel

Add some magic but not helm so everything still works fast :)

https://writequit.org/denver-emacs/presentations/2017-04-11-ivy.html

*** Window movement

    TODO Ctrl-Tab ---> next window
