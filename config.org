#+STARTUP: content

* emacs config

** Learning
*** Examples of emacs config

 - https://github.com/rememberYou/.emacs.d/blob/master/config.org
 - https://wolfecub.github.io/dotfiles/
 - https://github.com/gilbertw1/emacs-literate-starter/blob/master/emacs.org
 - https://github.com/emacs-tw/awesome-emacs
 - https://matthewbauer.us/bauer/

*** Emacs editor movement to remember

**** Movement
    - C-a, C-e: Begining/end of the line
    - M-a, M-e: Begining/end of a sentence
    - M-d     : Kill word (forward until next change of word
    - M-- M-d : Kill word (but backwards because the M-- means modifier -1)
    - 

**** Interesting Keybinding
    - M-;: Comment
    - F3 : Start Macro
    - F4 : Stops Macro
    - C-x z: Repeat last command (press z again without C-x to repeat)
    - C-M-i: Auto complete
    - C-SPC: Starts a region and adds a mark
    - C-x C-x: swaps cursor and mark
    - C-x C-e: Execute sexp after the cursor
    - . on dired mode: Shows dired hydra help menu

**** Help - Describe 
    - C-h f: Describe function
    - C-h m: Describe mode
    - C-h k: Describe key
    - C-h v: Describe variablle

**** Concepts

***** DWIM (Do What I Mean)

https://www.emacswiki.org/emacs/DoWhatIMean#DWIM

For example when setted the `dired-dwim-target` variable, if you have two windows with dired
and copy/move a file, will do directly with the other window. Because assumes that's what you want

#+BEGIN_SRC emacs-lisp

(setq dired-dwim-target t)


#+END_SRC



** config
*** Set GC

#+BEGIN_SRC emacs-lisp :tangle yes

(setq gc-cons-threshold 20000000)

#+END_SRC!

*** use-package
Configure use-package to install next package

#+BEGIN_SRC emacs-lisp :tangle yes
(require 'package)

(add-to-list 'package-archives '("melpa" . "https://melpa.org/packages/"))
(add-to-list 'package-archives '("org" . "http://orgmode.org/elpa/"))

(package-initialize)

;; install use-package if not installed
(unless (require 'use-package nil t)
    (package-refresh-contents)
    (package-install 'use-package)
    (require 'use-package))

;; install package if not already in
(setq use-package-always-ensure t)
#+END_SRC

*** Dimish

Diminish is used to no clutter the bottom bar with all the, one cool thing is that while
using use-package, you can add a :diminish to hide it directly

https://github.com/myrjola/diminish.el
#+BEGIN_SRC emacs-lisp :tangle yes

(use-package diminish)

#+END_SRC

*** Basic editing and UI
Configure basic UI, remove menu, scrollbar etc...

#+BEGIN_SRC emacs-lisp :tangle yes
(if (display-graphic-p)
(progn
    (menu-bar-mode -1)
    (toggle-scroll-bar -1)
    (tool-bar-mode -1)))
(defalias 'yes-or-no-p 'y-or-n-p)

#+END_SRC


Desktop save mode saves the session of the emacs between executions
More info: https://www.gnu.org/software/emacs/manual/html_node/emacs/Saving-Emacs-Sessions.html#Saving-Emacs-Sessions

#+BEGIN_SRC emacs-lisp :tangle yes

(desktop-save-mode 1)


(setq desktop-buffers-not-to-save
    (concat "\\("
	    "^nn\\.a[0-9]+\\|\\.log\\|(ftp)\\|^tags\\|^TAGS"
	    "\\|\\.emacs.*\\|\\.diary\\|\\.newsrc-dribble\\|\\.bbdb"
    "\\)$"))
(add-to-list 'desktop-modes-not-to-save 'dired-mode)
(add-to-list 'desktop-modes-not-to-save 'Info-mode)
(add-to-list 'desktop-modes-not-to-save 'info-lookup-mode)
(add-to-list 'desktop-modes-not-to-save 'fundamental-mode)

#+END_SRC

*** IDO 

IDO (Interactive DO) https://www.gnu.org/software/emacs/manual/html_mono/ido.html) 

is already built in into the Emacs system... it helps you when there are multiple options 
on the mini-buffer of emacs such as find-file or switch-buffer


#+BEGIN_SRC emacs-lisp :tangle yes
;; Since is already in we don't need to use-package it

(ido-mode 1)
(ido-everywhere 1)
#+END_SRC

*** Projectile

Projectile (https://github.com/bbatsov/projectile) 

Allow you to do find-file and search inside your project only

#+BEGIN_SRC emacs-lisp :tangle yes

(use-package projectile
:bind-keymap
("C-c p" . projectile-command-map))

#+END_SRC

*** OSX

#+BEGIN_SRC emacs-lisp :tangle yes
;; key bindings
(when (eq system-type 'darwin) ;; mac specific settings
(setq mac-option-modifier 'alt)
(setq mac-command-modifier 'meta)
(global-set-key [kp-delete] 'delete-char) ;; sets fn-delete to be right-delete
(setq mac-right-option-modifier 'none))


#+END_SRC

*** Load theme

#+BEGIN_SRC emacs-lisp :tangle yes

(use-package leuven-theme
:init (load-theme 'leuven t))

#+END_SRC

*** Clipboard

Make copy and paste from the clipboard work on emacs
from: http://ergoemacs.org/emacs/emacs_x11_sync_clipboard.html

#+BEGIN_SRC emacs-lisp :tangle yes

;; after copy Ctrl+c in Linux X11, you can paste by `yank' in emacs
(setq x-select-enable-clipboard t)

;; after mouse selection in X11, you can paste by `yank' in emacs
(setq x-select-enable-primary t)

#+END_SRC

*** Which Key

Which key is a minor mode that allow you to see which keystrokes are available after a prefix

For example: when you press C-c, after a second it would show up what are the next keybinding you can use

#+BEGIN_SRC emacs-lisp :tangle yes

(use-package which-key
:diminish
:config
(setq which-key-idle-delay 0.2)
(which-key-mode))


#+END_SRC

*** Undo tree

Undo tree allow you yo see how to undo/redo

#+BEGIN_SRC emacs-lisp :tangle yes

(use-package undo-tree
:diminish
:bind (
("C-z" . undo)
("C-c _" . undo-tree-visualize)
("C-S-z" . undo-tree-redo))
:config
(global-undo-tree-mode 1))

#+END_SRC

*** GIT!
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package magit
:bind (("C-c g" . magit-status)))
#+END_SRC

*** Expand Region

#+BEGIN_SRC emacs-lisp :tangle yes

(use-package expand-region
:ensure
:bind
(("C-+" . er/expand-region)
("C-M-+" . er/contract-region)))


#+END_SRC

*** Multiple cursors
https://github.com/magnars/multiple-cursors.el

Multiple cursors allow you to change multiple parts of the file that share some text

#+BEGIN_SRC emacs-lisp :tangle yes

(use-package multiple-cursors
:bind (("<f2>" . mc/mark-previous-like-this)
	("<f3>" . mc/mark-next-like-this)
	("C-c <f2>" . mc/mark-all-like-this)
	("<ESC> <ESC>" . mc/keyboard-quit))
:ensure t)

(use-package multiple-cursors
:bind
(("<C-S-down>" . mc/mark-next-like-this)
("<C-S-up>" . mc/mark-previous-like-this)
("C->" . mc/mark-next-like-this)
("C-<" . mc/mark-previous-like-this)
("C-S-c C-S-c" . mc/edit-lines)))

#+END_SRC

Since yet not fluent.... I have a hydra menu

C-c m c (Menu for cursors) allow you to open this menu

- n/p: to add a new cursor on next line
- N/P: skip next line to add a cursor
- a: (mark-all) will use the region as a search and add a cursor for each match
- r: does the same but with an regex on the current region
- C-Shift-c C-Shift-c: Add a cursor at the beginning of each line in the

*** Hydra menus


#+BEGIN_SRC emacs-lisp :tangle yes

  (use-package hydra
    :defer 2
    :bind (("C-c m w" . hydra-windows/body)
           ("C-c m c" . multiple-cursors-hydra/body)
           ("C-c m o" . hydra-org

#+END_SRC

**** Zoom  
  #+BEGIN_SRC emacs-lisp :tangle yes

  (defhydra hydra-windows (:color pink)
    "
    ^
    ^Windows^           ^Window^            ^Zoom^
    ^───────^───────────^──────^────────────^────^──────
    _q_ quit            _b_ balance         _-_ out
    ^^                  _i_ heighten        _+_ in
    ^^                  _j_ narrow          _=_ reset
    ^^                  _k_ lower           ^^
    ^^                  _l_ widen           ^^
    ^^                  ^^                  ^^
    "
    ("q" nil)
    ("B" balance-windows)
    ("i" enlarge-window)
    ("j" shrink-window-horizontally)
    ("k" shrink-window)
    ("l" enlarge-window-horizontally)
    ("-" text-scale-decrease)
    ("+" text-scale-increase)
    ("=" (text-scale-increase 0)))


  #+END_SRC

**** Org
#+BEGIN_SRC emacs-lisp :tangle yes

(defhydra hydra-org (:color red :columns 3)
  "Org Mode Movements"
  ("n" outline-next-visible-heading "next heading")
  ("p" outline-previous-visible-heading "prev heading")
  ("N" org-forward-heading-same-level "next heading at same level")
  ("P" org-backward-heading-same-level "prev heading at same level")
  ("u" outline-up-heading "up heading")
  ("g" org-goto "goto" :exit t))

#+END_SRC

**** Dired

#+BEGIN_SRC emacs-lisp :tangle yes

(defhydra hydra-dired (:hint nil :color pink)
  "
_+_ mkdir          _v_iew           _m_ark             _(_ details        _i_nsert-subdir    wdired
_C_opy             _O_ view other   _U_nmark all       _)_ omit-mode      _$_ hide-subdir    C-x C-q : edit
_D_elete           _o_pen other     _u_nmark           _l_ redisplay      _w_ kill-subdir    C-c C-c : commit
_R_ename           _M_ chmod        _t_oggle           _g_ revert buf     _e_ ediff          C-c ESC : abort
_Y_ rel symlink    _G_ chgrp        _E_xtension mark   _s_ort             _=_ pdiff
_S_ymlink          ^ ^              _F_ind marked      _._ toggle hydra   \\ flyspell
_r_sync            ^ ^              ^ ^                ^ ^                _?_ summary
_z_ compress-file  _A_ find regexp
_Z_ compress       _Q_ repl regexp

T - tag prefix
"
  ("\\" dired-do-ispell)
  ("(" dired-hide-details-mode)
  (")" dired-omit-mode)
  ("+" dired-create-directory)
  ("=" diredp-ediff)         ;; smart diff
  ("?" dired-summary)
  ("$" diredp-hide-subdir-nomove)
  ("A" dired-do-find-regexp)
  ("C" dired-do-copy)        ;; Copy all marked files
  ("D" dired-do-delete)
  ("E" dired-mark-extension)
  ("e" dired-ediff-files)
  ("F" dired-do-find-marked-files)
  ("G" dired-do-chgrp)
  ("g" revert-buffer)        ;; read all directories again (refresh)
  ("i" dired-maybe-insert-subdir)
  ("l" dired-do-redisplay)   ;; relist the marked or singel directory
  ("M" dired-do-chmod)
  ("m" dired-mark)
  ("O" dired-display-file)
  ("o" dired-find-file-other-window)
  ("Q" dired-do-find-regexp-and-replace)
  ("R" dired-do-rename)
  ("r" dired-do-rsynch)
  ("S" dired-do-symlink)
  ("s" dired-sort-toggle-or-edit)
  ("t" dired-toggle-marks)
  ("U" dired-unmark-all-marks)
  ("u" dired-unmark)
  ("v" dired-view-file)      ;; q to exit, s to search, = gets line #
  ("w" dired-kill-subdir)
  ("Y" dired-do-relsymlink)
  ("z" diredp-compress-this-file)
  ("Z" dired-do-compress)
  ("q" nil)
  ("." nil :color blue))

(define-key dired-mode-map "." 'hydra-dired/body)

#+END_SRC

**** Multiple Cursor

#+BEGIN_SRC emacs-lisp

(defhydra multiple-cursors-hydra (:hint nil)
  "
     ^Up^            ^Down^        ^Other^
----------------------------------------------
[_p_]   Next    [_n_]   Next    [_l_] Edit lines
[_P_]   Skip    [_N_]   Skip    [_a_] Mark all
[_M-p_] Unmark  [_M-n_] Unmark  [_r_] Mark by regexp
^ ^             ^ ^             [_q_] Quit
"
  ("l" mc/edit-lines :exit t)
  ("a" mc/mark-all-like-this :exit t)
  ("n" mc/mark-next-like-this)
  ("N" mc/skip-to-next-like-this)
  ("M-n" mc/unmark-next-like-this)
  ("p" mc/mark-previous-like-this)
  ("P" mc/skip-to-previous-like-this)
  ("M-p" mc/unmark-previous-like-this)
  ("r" mc/mark-all-in-region-regexp :exit t)
  ("q" nil))

#+END_SRC


** TODO

*** Evil ????? 

I want evil just for movement but not for anything else...

#+BEGIN_SRC emacs-lisp :tangle yes

(use-package evil)

#+END_SRC

For the moment I install the package but not used by default but
you need to start it by M-x evil-mode

Also found this for better having some keybindings from emacs like
C-e and C-f etc...
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package evil
  :config
  (define-key evil-normal-state-map "\C-e" 'evil-end-of-line)
  (define-key evil-insert-state-map "\C-e" 'end-of-line)
  (define-key evil-visual-state-map "\C-e" 'evil-end-of-line)
  (define-key evil-motion-state-map "\C-e" 'evil-end-of-line)
  (define-key evil-normal-state-map "\C-f" 'evil-forward-char)
  (define-key evil-insert-state-map "\C-f" 'evil-forward-char)
  (define-key evil-insert-state-map "\C-f" 'evil-forward-char)
  (define-key evil-normal-state-map "\C-b" 'evil-backward-char)
  (define-key evil-insert-state-map "\C-b" 'evil-backward-char)
  (define-key evil-visual-state-map "\C-b" 'evil-backward-char)
  (define-key evil-normal-state-map "\C-d" 'evil-delete-char)
  (define-key evil-insert-state-map "\C-d" 'evil-delete-char)
  (define-key evil-visual-state-map "\C-d" 'evil-delete-char)
  (define-key evil-normal-state-map "\C-n" 'evil-next-line)
  (define-key evil-insert-state-map "\C-n" 'evil-next-line)
  (define-key evil-visual-state-map "\C-n" 'evil-next-line)
  (define-key evil-normal-state-map "\C-p" 'evil-previous-line)
  (define-key evil-insert-state-map "\C-p" 'evil-previous-line)
  (define-key evil-visual-state-map "\C-p" 'evil-previous-line)
  (define-key evil-normal-state-map "\C-w" 'evil-delete)
  (define-key evil-insert-state-map "\C-w" 'evil-delete)
  (define-key evil-visual-state-map "\C-w" 'evil-delete)
  (define-key evil-normal-state-map "\C-y" 'yank)
  (define-key evil-insert-state-map "\C-y" 'yank)
  (define-key evil-visual-state-map "\C-y" 'yank)
  (define-key evil-normal-state-map "\C-k" 'kill-line)
  (define-key evil-insert-state-map "\C-k" 'kill-line)
  (define-key evil-visual-state-map "\C-k" 'kill-line))

#+END_SRC


*** Eyebrowser / perspective

I would love yo have a way to organize my code programming like a shell at the bottom and a 
tree (dired) and a couple of buffers and be able to switch between them fast and easy just 
like in sublime or something :)

*** Ivy / Swipper / Counsel

Add some magic but not helm so everything still works fast :)
